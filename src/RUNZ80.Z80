; CP/M UTILITY FOR COBRA TO LOAD AND EXECUTE A .Z80
; SNAPSHOT FILE
; 
; USAGE:
; RUNZ80 FILE[.Z80]


; BDOS ENTRY POINT
BDOS EQU 5

; BDOS FUNCTIONS
SYSRESET EQU 0
CONOUT EQU 2
PRINTS EQU 9
OPEN EQU 15
READSEQ EQU 20

; FILE ARGUMENT FCB
FCB1 EQU 005CH
; DESTINATION OF FILE LOADS
DMA EQU 0080H


; LOCATION OF RESTORE ROUTINE IN ZX SPECTRUM MEMORY
; VRAM PLUS 4 BYTES OF STACK FOR THE RESTORE ROUTINE
Z80RESTORE EQU 4004H

; LOAD ADDRESS FOR SNAPSHOT MEMORY. MUST BE HIGH ENOUGH FOR
; (MOST OF) THIS PROGRAM TO FIT UNDERNEATH IT.  SOME OF IT
; IS USED FOR TEMPORARY STORAGE - SEE ORG Z80MEM.
Z80MEM EQU 0600H
; END OF SNAPSHOT MEMORY
Z80MEMEND EQU Z80MEM + 0BFFFH


ORG 100H

START:
	LD DE,FCB1+9	; ADD "Z80" EXTENSION
	LD HL,EXT
	LDI
	LDI
	LDI
	CALL OPENFILE
	CALL LOADZ80
	CALL COPYRESTORE
	JP LOADER
EXIT:
	LD C,SYSRESET
	JP BDOS
ERROR:
	LD DE,ERRORMSG
	LD C,PRINTS
	CALL BDOS
	JR EXIT

EXT: DB 'Z80'


; OPEN FILE SPECIFIED BY FCB1
OPENFILE:
	LD C,OPEN	; OPEN FILE ARGUMENT
	LD DE,FCB1
	CALL BDOS
	SUB 0FFH	; FF INDICATES ERROR
	RET NZ
	LD C,PRINTS	; PRINT ERROR AND QUIT
	LD DE,EOPENMSG
	CALL BDOS
	JP EXIT


; READ THE NEXT BLOCK FROM FILE SPECIFIED BY FCB1 INTO DMA
READBLOCK:
	LD C,READSEQ
	LD DE,FCB1
	CALL BDOS
	AND A
	RET Z
	JP ERROR

; LOAD A .Z80 SNAPSHOT FROM AN OPEN FILE
LOADZ80:
	CALL READBLOCK		; LOAD HEADERS
	LD HL,DMA		; COPY HEADERS
	LD DE,HEADERS
	LD BC,87
	LDIR
	LD A,(HDR1_FLAGSA)	; GET BIT 7 OF R
	RRCA
	AND 80H
	LD HL,HDR1_R
	OR (HL)
	LD (HL),A
	LD A,(HDR1_FLAGSA)	; GET BORDER
	RRCA
	AND 07H
	LD (BORDER),A
	CALL GENRST		; GENERATE RESTORE CODE FROM HEADER
	LD HL,(HDR1_PC)		; CHECK VERSION AND LOAD MEMORY SNAPSHOT
	LD A,H
	AND A
	JP NZ,LOADV1
	LD A,L
	AND A
	JP NZ,LOADV1
	JP LOADV23


; INDIRECT JUMP THROUGH IX.  USED TO DYNAMICALLY CALL
; LOADBYTE OR LOADBYTE_COUNTED DEPENDING ON VERSION OF THE
; SNAPSHOT FILE.  V2/V3 SPECIFY THE LENGTH OF MEMORY BLOCKS
; (LOADBYTE_COUNTED).  V1 DOES NOT (LOADBYTE).
JPIX:
	JP (IX)

; RETURN FROM THE CALLING FUNCTION.  USED BY
; LOADBYTE_COUNTED TO RETURN FROM LOADUNCOMP/LOADCOMP/SEEK
; WHEN THE END OF THE BLOCK IS REACHED.
RETCALLER:
	INC SP
	INC SP
	RET

; WRAP A DECREMENT AND COMPARE AROUND LOADBYTE TO RUN
; LOADBYTE BC TIMES
LOADBYTE_COUNTED:
	LD A,B			; CHECK BC FOR 0
	OR C
	JR Z,RETCALLER		; IF 0 RETURN FROM CALLER
	DEC BC

; LOAD NEXT BYTE INTO A, RELOADING BUFFER FROM DISK WHEN
; NECESSARY
LOADBYTE:
	LD A,L			; SEE IF WE HAVE OVERFLOWED
	AND A
	JR NZ,LOADBYTE_RET
	PUSH BC			; SAVE REGS
	PUSH DE
	PUSH IX
	LD C,READSEQ		; LOAD ANOTHER FROM DISK IF SO
	LD DE,FCB1
	CALL BDOS
	POP IX
	POP DE
	POP BC
	AND A			; CHECK READSEQ RETURN
	JP NZ,ERROR
	LD HL,DMA		; RETURN TO START OF DMA
LOADBYTE_RET:
	LD A,(HL)
	INC L
	RET

; LOAD BC BYTES OF UNCOMPRESSED SNAPSHOT MEMORY
LOADUNCOMP:
	CALL LOADBYTE_COUNTED
	LD (DE),A
	INC DE
	JR LOADUNCOMP

; LOAD AND UNCOMPRESS COMPRESSED DATA UNTIL END OF BLOCK
LOADCOMPV1:
	LD IX,LOADBYTE
	JR LOADCOMP
; LOAD AND UNCOMPRESS BC BYTES OF COMPRESSED DATA
LOADCOMPV23:
	LD IX,LOADBYTE_COUNTED
; LOAD AND UNCOMPRESS COMPRESSED DATA
LOADCOMP:
	CALL JPIX		; GET NEXT BYTE
	CP 0EDH			; CHECK FOR FIRST ED
	JR NZ,LOADCOMP_NOED
	LD (DE),A		; STORE THE FIRST ED
	INC DE
	CALL JPIX		; GET NEXT BYTE
	CP 0EDH			; CHECK FOR SECOND ED
	JR NZ,LOADCOMP_NOED
	CALL JPIX		; FOUND SECOND DE, LOAD N
	AND A			; CHECK FOR N=0, END OF BLOCK
	RET Z			; END OF BLOCK FOUND
	DEC A
	LD (FILLCOUNT),A
	CALL JPIX		; LOAD X, A = X
	DEC DE			; REWIND TO FIRST ED
	PUSH BC			; FILL (FILLCOUNT) WITH (FILLVALUE)
	PUSH AF			; SAVE FILL VALUE
	LD A,(FILLCOUNT)
	LD B,A
	POP AF			; RESTORE FILL VALUE
LOADCOMP_FILL:
	LD (DE),A
	INC DE
	DJNZ LOADCOMP_FILL
	POP BC
LOADCOMP_NOED:
	LD (DE),A		; STORE A NON-ED BYTE
	INC DE
	JR LOADCOMP

FILLCOUNT: DB 0

; SKIP BC BYTES OF THE FILE
SEEK:
	CALL LOADBYTE_COUNTED
	JR SEEK

; LOAD A V1 .Z80 FILE
LOADV1:
	LD DE,V1MSG
	LD C,PRINTS
	CALL BDOS
	LD DE,Z80MEM		; LOAD REST OF BLOCK 1
	LD HL,DMA + 30
	LD A,(HDR1_FLAGSA)	; CHECK IF COMPRESSED
	BIT 5,A
	JP NZ,LOADCOMPV1
	LD BC,48*1024
	JP LOADUNCOMP

; LOAD A V2/V3 .Z80 FILE
LOADV23:
	LD DE,V23MSG
	LD C,PRINTS
	CALL BDOS
	LD DE,RST_PC		; USE PC FROM ADDITIONAL HEADER IN RESTORE
	LD HL,HDR2_PC
	LDI
	LDI
	PUSH HL			; GET AY-3 REGS FROM HEADER
	LD DE,AY3HEADER
	LD HL,DMA+38
	LD BC,17
	LDIR
	POP HL
	LD HL,DMA+32		; SEEK PAST HEADERS
	LD BC,(DMA+30)
	CALL SEEK
	CALL LOADPAGE
	CALL LOADPAGE
	CALL LOADPAGE
	RET

; LOAD A V2/V3 PAGE
LOADPAGE:
	CALL LOADBYTE		; READ LENGTH INTO BC
	LD C,A
	CALL LOADBYTE
	LD B,A
	CALL LOADBYTE		; READ PAGE NUMBER INTO A
	CP 4			; SET DE=DEST AND LOAD IF PAGE 4, 5, or 8
	JR NZ,LOADPAGE_NOT4
	LD DE,8000H-4000H+0600H
	JR LOADPAGE_LOAD
LOADPAGE_NOT4:
	CP 5
	JR NZ,LOADPAGE_NOT5
	LD DE,0C000H-4000H+0600H
	JR LOADPAGE_LOAD
LOADPAGE_NOT5:
	CP 8
	JR NZ,LOADPAGE_NOT8
	LD DE,4000H-4000H+0600H
	JR LOADPAGE_LOAD
LOADPAGE_NOT8:
	PUSH HL			; SKIP TO NEXT PAGE AND TRY TO LOAD
	LD HL,SKIPMSG
	CALL PAGESTATUS
	POP HL
	LD A,B			; CHECK BC FOR FFFF
	AND C
	CPL
	AND A
	JR NZ,LOADPAGE_SEEK
	LD BC,16384
LOADPAGE_SEEK:
	CALL SEEK
	JR LOADPAGE
LOADPAGE_LOAD:
	PUSH HL			; PRINT LOADING MESSAGE
	LD HL,LOADMSG
	CALL PAGESTATUS
	POP HL
	LD A,B			; CHECK BC FOR FFFF
	AND C
	CPL
	AND A
	JP NZ,LOADCOMPV23	; LOAD COMPRESSED IF NOT FFFF
	LD BC,16384		; LOAD UNCOMPRESSED IF FFFF
	JP LOADUNCOMP

; PRINT MESSAGE FROM HL PLUS PAGE NUMBER IN HEX
PAGESTATUS:
	PUSH BC
	PUSH DE
	PUSH AF
	LD C,PRINTS
	PUSH HL
	POP DE
	CALL BDOS
	POP AF
	PUSH AF
	CP 0AH
	JP C,PAGESTATUS_NUMBER
	ADD 7
PAGESTATUS_NUMBER:
	ADD 30H
	LD E,A
	LD C,CONOUT
	CALL BDOS
	LD E,0DH
	LD C,CONOUT
	CALL BDOS
	LD E,0AH
	LD C,CONOUT
	CALL BDOS
	POP AF
	POP DE
	POP BC
	RET


; COPY GENERATED RESTORE INTO SNAPSHOT MEMORY
COPYRESTORE:
	LD DE,Z80RESTORE - 4000H + Z80MEM
	LD HL,RESTORE
	LD BC,RESTOREEND-RESTORE
	LDIR
	RET


; STATUS/ERROR STRINGS
EOPENMSG: DB 'File not found',0DH,0AH,'$'
V1MSG: DB 'Detected version 1',0DH,0AH,'$'
V23MSG: DB 'Detected version 2+',0DH,0AH,'$'
ERRORMSG: DB 'Unexpected end of file',0DH,0AH,'$'
SKIPMSG: DB 'Skipping page $'
LOADMSG: DB 'Loading page $'

; AY3 HEADER FROM V2/V3 HEADER
AY3HEADER:
LASTFFFD: DB 0
AY3REGS: DS 16,0

; BORDER COLOR FROM HEADER
BORDER: DB 0

INCLUDE RESTORE.Z80
INCLUDE LOADER.Z80

; MEMORY PAST HERE IS OVERWRITTEN WITH SNAPSHOT MEMORY
; AFTER HEADERS ARE PROCESSED
ORG Z80MEM
HEADERS:
INCLUDE HEADER.Z80
INCLUDE GENRST.Z80

END
